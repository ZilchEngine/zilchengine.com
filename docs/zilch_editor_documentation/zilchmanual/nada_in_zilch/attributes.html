<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Using Attributes | ZilchEngine </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Using Attributes | ZilchEngine ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ZilchEngine/ZilchEngineWebsite/blob/master/docs/zilch_editor_documentation/zilchmanual/nada_in_zilch/attributes.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../images/ZilchLogo.svg" alt="ZilchEngine">
            ZilchEngine
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">

<p>Attributes are part of the Nada grammar allowing additional information to be associated with other Nada constructs, i.e. they may be applied to classes, fields, get-sets, and functions. While some attributes are inherent to the Nada programming language, the program embedding Nada may create and assign their own meaning to new attributes as appropriate for their scripting needs. This means that some attributes exist in Nada, the standalone language, while others are available in Nada due to the extensions made by the Zilch Engine in which it is embedded.</p>
<h1 id="using-attributes">Using Attributes</h1>
<p>In Nada, attributes can be assigned by annotating the affected construct with a capitalized name of the recognized attribute in square brackets above the definition:</p>
<pre><code class="lang-TS:Assigning">[Virtual] // Here we've added the attribute &quot;Virtual&quot; to the function Speak
function Speak() : String
{
  return &quot;...&quot;;
}
</code></pre>
<h1 id="existing-attributes">Existing Attributes</h1>
<p>The following are usable in the Zilch Engine:</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>From</th>
<th>High Concept</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[Static]</code></td>
<td>Nada</td>
<td>Makes construct static</td>
</tr>
<tr>
<td><code>[Virtual]</code></td>
<td>Nada</td>
<td>Marks a construct as a polymorphic base</td>
</tr>
<tr>
<td><code>[Override]</code></td>
<td>Nada</td>
<td>Marks a construct as overriding a base construct</td>
</tr>
<tr>
<td><code>[Extension(typeid(OtherType))]</code></td>
<td>Nada</td>
<td>Appends construct to preexisting <code>OtherType</code></td>
</tr>
<tr>
<td><code>[Display]</code></td>
<td>Zilch</td>
<td>Allows construct to appear in Property Grid</td>
</tr>
<tr>
<td><code>[Serialize]</code></td>
<td>Zilch</td>
<td>Allows construct value to be saved by Zilch</td>
</tr>
<tr>
<td><code>[Property]</code></td>
<td>Zilch</td>
<td>Combines <code>[Display]</code> and <code>[Serialize]</code></td>
</tr>
<tr>
<td><code>[Dependency]</code></td>
<td>Zilch</td>
<td>Enables Zilch to enforce explicit dependencies</td>
</tr>
<tr>
<td><code>[RunInEditor]</code></td>
<td>Zilch</td>
<td>Allows code to run in the editor</td>
</tr>
<tr>
<td><code>[Tool]</code></td>
<td>Zilch</td>
<td>Can run in editor and accessible in Tools Window</td>
</tr>
<tr>
<td><code>[Command]</code></td>
<td>Zilch</td>
<td>Can run in editor and accessible in Search Window</td>
</tr>
<tr>
<td><code>[ComponentInterface]</code></td>
<td>Zilch</td>
<td>Defines a class as a generic interface for derived classes</td>
</tr>
</tbody>
</table>
<p>(IMPORTANT)<strong>Deprecation Warning</strong>: The <code>[Editable]</code> and <code>[Serialized]</code> attributes were #deprecated in release <a href="https://dev.zilchengine.com/source/ZeroCore/browse/releases%252F1.1.0/;d3c079aaf84bf52abb6e1c43e8ca88361cd70b10">1.1.0</a> and will be removed in the next major version of the engine. Use <code>[Property]</code> and <code>[Serialize]</code> for all engine versions <code>1.1.0</code> and newer.</p>
<h2 id="static">[Static]</h2>
<p>Static can be used on function, fields, and get-sets. These allow you to access fields, get-sets, and functions without first creating an instance of the class in your code.</p>
<pre><code class="lang-TS:Defining">  class Mathematics
  {
      [Static]
      var PI: Real{ get{return 3.14159292;}}
      [Static]
      function Circumference(radius : Real) : Real
      {
          return Mathematics.PI * radius * radius;
      }
  }
</code></pre>
<p>Given the class above you can use its functionality by calling into the class's namespace:</p>
<pre><code class="lang-TS:Using">  var myNewFavoriteNumber = Mathematics.PI + Mathematics.Circumference(2.0);
  Console.WriteLine(My new favorite number is: `myNewFavoriteNumber`&quot;);
</code></pre>
<p>will result in</p>
<pre><code class="lang-name=ConsoleWindow">My new favorite number is: 15.708
</code></pre>
<p>NOTE: While these attributes enable polymorphism, they are still in their infancy. Virtual is to be used with the base class field/get-set/function, while Override is for all the derived classes seeking to write over the base class's field/get-set/function. That said, mixing up <code>[Virtual]</code> and <code>[Override]</code> , or forgetting the use of the <code>[Override]</code> may still provide desired results. To promote forward compatibility, we highly encourage the correct, indicated usage.</p>
<h2 id="virtual">[Virtual]</h2>
<p>Virtual is used to give Base classes the ability to determine some functions as being able to be overridden by its derived classes.</p>
<pre><code class="lang-TS:Applying">class Animal
{
  [Virtual]
  function Speak() : String
  {
    return &quot;...&quot;;
  }
}
</code></pre>
<h2 id="override">[Override]</h2>
<p>Override is used by a derived class to mark the intentional overriding of a base class's virtual function.</p>
<pre><code class="lang-TS:Applying">class Dog : Animal
{
  [Override]
  function Speak() : String
  {
    return &quot;Woof&quot;;
  }
}
</code></pre>
<h2 id="extensiontypeidothertype">[Extension(typeid(OtherType))]</h2>
<p>This allow you to add functionality to a preexisting class from inside another. Currently, you can only extend a class by adding get-sets and functions (i.e. you cannot add fields). If a function is being added to an existing class (<code>Math</code>, for example), the [Static] attribute should also be used:</p>
<pre><code class="lang-TS:Applying">class MyClass : NadaComponent
{
  [Extension(typeid(Math))][Static]
  function Circumference(radius : Real) : Real
  {
    return Mathematics.PI * radius * radius;
  }
}
</code></pre>
<p>Zilch works with Nada to offer these additional attributes:</p>
<h2 id="display">[Display]</h2>
<p>Allows you to set a field or get-set via the Property Grid in the editor. Because this doesn't save the settings, it is usually used in conjunction with either <code>[RunInEditor]</code> or <code>[Serialize]</code> . For example, changing</p>
<pre><code class="lang-TS:Variable">class MyClass : NadaComponent
{
  var MyVariable : Real;
}
</code></pre>
<p>to</p>
<pre><code class="lang-TS:Variable">[Editiable]
var MyVariable : Real;
</code></pre>
<p>results in the the variable appearing in the Property Grid in Properties window:</p>
<p><img src="https://raw.githubusercontent.com/ZilchEngine/ZilchFiles/master/doc_files/66612.png" alt="Editable"></p>
<h2 id="serialize">[Serialize]</h2>
<p>Allows a value to be saved by the Engine. This allows a field and get-sets to be saved with ObjectStore. When used with <code>[Display]</code> it allows the values to be saved from the Property Grid so that they may be loaded in an instance of the game.</p>
<h2 id="property">[Property]</h2>
<p>Property wraps the <code>[Display]</code> and <code>[Serialize]</code> attributes together into one. As implied by the use of <code>[Display]</code> and <code>[Serialize]</code>, it works on fields and get-sets. Properties of certain types will result in unique set fields in the Property Grid. For example,</p>
<pre><code class="lang-TS:Variables">class MyClass
{
  [Property]
  var MyColor : Real4;

  [Property]
  var  MyMaterial : Material;
}
</code></pre>
<p>results in</p>
<p><img src="https://raw.githubusercontent.com/ZilchEngine/ZilchFiles/master/doc_files/66615.png" alt="Property"></p>
<h2 id="dependency">[Dependency]</h2>
<p>Allows the programmer to make a dependency between components explicit. This allows users to determine the interrelatedness without having intimate knowledge of a component's inner workings. The Zilch Engine supports this by requiring dependencies to be added prior to attaching the component, preventing the removal of dependencies while the component is still attached, and safeguarding the order of initialization of components such that the dependencies will always be initialized first.</p>
<p>The below sample demonstrates the declaration of a dependence upon another component:</p>
<pre><code class="lang-TS:Applying">  class SimpleOffset : NadaComponent
  {
      // Declaring that SimpleOffset depends upon Transform component.
      [Dependency]
      var Transform : Transform = null; 
      function Initialize(init : CogInitializer)
      {
          // This declaration also physically adds that variable to our fields: 
          // Since this.Transform contains the component we have a dependency 
          // on, we can access it without going through the Owner. 
          this.Transform.Translation += Real3(0,5,0);
      }
  }
</code></pre>
<p>The <code>[Dependency]</code> attribute may also be used on get-sets.</p>
<p>NOTE: <strong>Did you know?</strong> When working in the editor, the space the objects operate in is paused. This means that the <code>LogicUpdate</code> event will never fire, and that Actions on objects never get updated! In order to receive continuous events, the object should connect to <code>UpdateFrame</code> instead.</p>
<h2 id="runineditor">[RunInEditor]</h2>
<p>When placed on a class derived from NadaComponent, it changes proxy objects into live objects upon being attached in the editor. This means that the object will run its code in the editor. When <em>any</em> scripting file is saved in the editor, all live objects (i.e. those with the RunInEditor component attached) will, by default, have their object destroyed, recreated, and its data reinitialized.</p>
<p>IMPORTANT: Any code you choose to run via <code>[RunInEditor]</code> can result in editor instability. For instance, if you choose to loop through and destroy all the objects and save your game you may lose your ability to recover the lost objects, and have to recreate them by hand. Undo and Redo operations for RunInEditor components must be handled by the programmer!</p>
<h2 id="tool">[Tool]</h2>
<p>Allows for a tool to be hooked into the Tools Window such that it shows up in the drop down menu, and can be used in the editor. When creating a new custom tool, a good starting point is generating the NadaScript with the Tool template chosen in the Add Window.</p>
<h2 id="command">[Command]</h2>
<p>Allows for a class to be hooked into the command system such that it shows up, and can be ran, from Zilch's Search Window. The following Paste provides a template for a custom Command that creates an object based on an archetype, allowing the user to make their own &quot;Create&quot; commands similar to <code>CreateCube</code> and <code>CreateSphere</code>:</p>
<pre><code>[Command(autoRegister:true)]
class CreateArchetype : NadaComponent
{
  // The archetype from which to create an object
  var ArchetypeToCreate : Archetype = Archetype.MyObject;
  
  // The position at which to create the object
  var Position : Real3 = Real3(0, 1, 0);
  
  function Initialize(init : CogInitializer)
  {
    Zilch.Connect(this.Owner, Events.CommandExecute, this.OnCommandExecute);
  }

  function OnCommandExecute(event : CommandEvent)
  {
    var selection = Zilch.Editor.Selection;
    selection.SelectOnly(this);
    selection.FinalSelectionChanged();
    
    this.CreateObject();
  }
  
  function CreateObject()
  {
    // Create the object in Editor space
    var editorSpace = Zilch.Editor.EditSpace;
    editorSpace.CreateAtPosition(this.ArchetypeToCreate, this.Position);
  }
}

</code></pre>
<h2 id="componentinterface">[ComponentInterface]</h2>
<p>The ComponentInterface attribute allows the user to define a class as a generic interface for its derived types. One common example of this is <a href="../../../code_reference/class_reference/collider.html">collider</a>, which acts as a component interface for all collider types, such as <a href="../../../code_reference/class_reference/boxcollider.html">boxcollider</a>, <a href="../../../code_reference/class_reference/capsulecollider.html">capsulecollider</a>, and more. Defining an interface using this attribute allows the user to access the members of a derived class using the component name of the base class.</p>
<pre><code class="lang-TS:Component">var collisionGroup = this.Owner.BoxCollider.CollisionGroup;
var collisionGroupAccessedByInterface = this.Owner.Collider.CollisionGroup;

if(collisionGroup == collisionGroupAccessedByInterface)
  Console.WriteLine(&quot;These variables reference the same component&quot;);
</code></pre>
<p>Using a component interface does not mean that the property and methods of a derived class need to be exactly the same as the base class. What would be the point? Using the <a href="../../../sandbox/arend_danielek/attributes.md#virtual"> Virtual</a> and <a href="../../../sandbox/arend_danielek/attributes.md#override"> Override </a> attributes, we can modify the interface of derived classes.</p>
<pre><code class="lang-TS:Component">[ComponentInterface]
class AnimationDebugNode : NadaComponent
{
  [Virtual]
  var Node : AnimationNode;
  
  function Initialize(init : CogInitializer)
  {
    
  }
}

class SelectiveDebugNode : AnimationDebugNode
{
  [Override]
  var Node : SelectiveNode;
}

class DirectBlendDebugNode : AnimationDebugNode
{
  [Override]
  var Node : DirectBlend;
}

class CrossBlendDebugNode : AnimationDebugNode
{
  [Override]
  var Node : CrossBlend;
}
</code></pre>
<h1 id="parameters-in-attributes">Parameters in Attributes</h1>
<p>Attributes can also take parameters; below is the template generated for creating a new Command by Zilch:</p>
<pre><code class="lang-TS">[Command(autoRegister:true)] // This template file sets a parameter, autoRegister, to true.
class MyNewCommand : NadaComponent
{
  function Initialize(init : CogInitializer)
  {
      Zilch.Connect(this.Owner, Events.CommandExecute, this.OnCommandExecute);
  }

  function OnCommandExecute(event : CommandEvent)
  {
    Console.WriteLine(&quot;MyNewCommand Command Executed&quot;);
  }
}
</code></pre>
<p>At this time, only Extension, Tool, and Command attributes take parameters.</p>
<ul>
<li><p>Extension requires the type you are using to extend the attribute, as a parameter.</p>
</li>
<li><p>Tool and Command have the optional parameter to automatically register the component with the engine.</p>
</li>
</ul>
<p>To manually register, you would add these components to an archetype and then add the Tool or Command editor tag via the Library Window, respectively. Registering manually gives you access to the archetype, making it possible to leverage component-based design in the construction of new Tools and Commands.</p>
<h1 id="related-materials">Related Materials</h1>
<h2 id="manual">Manual</h2>
<ul>
<li><a href="inheritance.html">inheritance</a></li>
<li><a href="variables_and_data_types.html">variables_and_data_types</a></li>
<li><a href="../scripting/wysiwyg.html">wysiwyg</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ZilchEngine/ZilchEngineWebsite/blob/master/docs/zilch_editor_documentation/zilchmanual/nada_in_zilch/attributes.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          ZilchEngine 2024
        </div>
      </div>
    </footer>
  </body>
</html>
