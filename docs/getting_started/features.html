<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Ten Exciting Features of the Zilch Engine (and also Spaces) | ZilchEngine </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Ten Exciting Features of the Zilch Engine (and also Spaces) | ZilchEngine ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ZilchEngine/ZilchEngineWebsite/blob/master/docs/getting_started/features.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/ZilchLogo.svg" alt="ZilchEngine">
            ZilchEngine
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="ten-exciting-features-of-the-zilch-engine-and-also-spaces">Ten Exciting Features of the Zilch Engine (and also Spaces)</h1>

<h2 id="events">Events</h2>
<p>Zilch Engine's Event system takes component-based design to new levels of freedom and flexibility. A Zilch Engine Event mimics its real-world counterpart: a situation that arises. How your game handles that situation is up to you. When your hero takes damage, the camera following her can shake. When a cannonball reaches the apex of its flight, an audio filter can be applied to the level's music. Every game object is a potential event dispatcher, and every object's events are up for grabs. When you work with events from the beginning of a project, you allow yourself greater freedom to rapidly explore new features and ideas with minimal refactoring of your existing code.</p>
<h2 id="nested-archetypes">Nested Archetypes</h2>
<p>An archetype defines a game object, its child objects, and even other nested archetypes within the hierarchy. Need to make changes to an Archetype that is nested under multiple of other Archetypes? We've got you covered. Every Archetype will automatically receive updates made to nested Archetypes. Did all those Archetypes have local modifications made to the nested one? We've still got you covered. Zilch Engine preserves local modifications when updates are made to an Archetype.</p>
<h2 id="nada">Nada</h2>
<p>Nada is a high-level programming language developed by us to solve some of the most interesting problems in game development. Use Nada to program and customize game scripts, editor tools and commands, and even your shaders. All of that, done in an integrated text editor equipped with full code completion and inline tooltips from documentation. Nada features extremely fast compilation and patching/hot loading for live game editing.</p>
<h2 id="c-plugins">C++ Plugins</h2>
<p>Scripts are awesome, but at the end of the day they can't do everything that life has to offer. Whether it's a library that you want to use or you need to do some heavy lifting for performance reasons, C++ can always get the job done. With a C++ plugin you have all the power you need, wrapped up and ready to use in your game. There's no complicated setup, just create a new plugin resource and it will make you a Visual Studio solution, pre-hooked with a new component. Changes to your plugin are automatically detected by Zilch Engine, and your project updates itself on the spot.</p>
<h2 id="lightweight-game-objects">Lightweight Game Objects</h2>
<p>Zilch Engine's game objects are lightweight and versatile. We call them cogs because they're 'Game Object Compositions' (and “gocs” doesn't sound as cool). Cogs can house as many components and child objects as needed, and the engine is incredibly good at making and destroying them, so you never have to worry about object pooling.</p>
<h2 id="shader-compositing">Shader Compositing</h2>
<p>Zilch Engine's Materials are a component based way to write shaders. Write individual shader fragments to encapsulate a desired behavior, and add the fragments you want to your Materials, just like components, to create the desired effects. The shader compositor does all the work of putting the components together to create a complete shader program for graphics hardware. It also controls the flow of inputs and outputs between fragments, so that a single fragment can modify data, like UV coordinates, before it is used as input to a following fragment.</p>
<h2 id="scriptable-rendering-pipeline">Scriptable Rendering Pipeline</h2>
<p>We're in the business of rapid iteration, and the rendering pipeline is no exception. Zilch Engine offers unparalleled control over the aesthetics of your game with the ability for scripts to define a series of tasks for the renderer. Written in script, your rendering pipeline becomes anything you can imagine, make your pipeline change dynamically with a simple condition, or even in response to an Event. Add any rendering technique to your game, including the ones that haven't been invented yet. But there's no need start from scratch: Zilch Engine comes pre-loaded with all the scripts and shaders needed for a modern physically based rendering pipeline. If that's what you're looking for, you're done. If you want more, you can use it as a starting point for customization.</p>
<h2 id="scriptable-sound-nodes">Scriptable Sound Nodes</h2>
<p>Zilch Engine features a powerful custom audio system. At its core is the sound node graph, a flexible, fully scriptable structure that controls the flow of audio through your game. Sound nodes can play or generate audio, apply effects, control parameters, and more, and they can be added, removed, and swapped at any time. When the sound node graph is used together with Zilch Engine's built-in event system, it's easy to apply DSP effects to just the right sounds, just when you need them.</p>
<h2 id="in-house-physics">In-House Physics</h2>
<p>Like most things in the Zilch Engine, our physics system is developed by us. That may seem like an unnecessary amount of work, but we want features that pair well with the design and vision for Zilch Engine as a whole and we don't want to be held back. Zilch Engine's physics system includes features like collision groups that allow detection without resolution, regions that can apply force effects, and even scriptable joint definitions that run through our constraint solver.</p>
<h2 id="one-click-network-replication">One-Click Network Replication</h2>
<p>Networking is easy! ... Okay we're kidding, but the road to easier networking is full of innovation, and what's easier than one mouse click? Zilch Engine continues to use component based design to every advantage we can come up with. Just add the NetObject component and now any property from your object can be replicated over the network with a single click of a button in the UI. Start from our networked project template to get a head start with some of the harder stuff.</p>
<h2 id="spaces">Spaces</h2>
<p>The concept of the space is quite unique: a space is a collection of game objects that interact normally with one another, but not with objects in other spaces. Physics is simulated in each space separately, so objects in two spaces running simultaneously could experience completely different gravity, force effects, and collision rules. Separate spaces can be paused independently, so your game can be frozen in one space while the animations keep going in another, such as in a menu. The output of cameras from separate spaces can be overlaid, split screened, or embedded in objects in a level, so an in-world TV screen could be used to play a game-within-a-game. A space can even be created with no cameras in it at all, serving instead as a storage repository for data that should persist between levels or even networked game sessions.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ZilchEngine/ZilchEngineWebsite/blob/master/docs/getting_started/features.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          ZilchEngine 2024
        </div>
      </div>
    </footer>
  </body>
</html>
